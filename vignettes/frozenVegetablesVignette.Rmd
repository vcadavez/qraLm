---
title: "QRA models functions for frozen vegetables"
description: >
  QRA models for frozen vegetables
author: "Vasco Cadavez, Laurent Guillier, RÃ©gis Pouillot, Moez Sanaa, Ursula Gonzales-Barron"
date: "`r Sys.Date()`"
output: 
  rmarkdown::html_vignette:
     number_sections: yes
     toc: yes
vignette: >
  %\VignetteIndexEntry{QRA models functions for frozen vegetables}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
  \usepackage{caption}
  \usepackage{amssymb, amsmath}
csl: ../inst/apa.csl
bibliography: ../inst/REFERENCES.bib
---

```{r setup, echo = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE, warning = FALSE, message = FALSE,
  comment = "#>"
)
```


```{r libs, echo=FALSE}
library(Hmisc)
library(dplyr)
library(DT)
#library(rbokeh)
library(qraLm)
library(extraDistr)
library(mc2d)
library(ggplot2)
library(doseresponsemodels)
library(plotly)
#library(kableExtra)
```

## Production

This is the initial contamination. The output objects is a list with `P`, the
prevalence of contaminated lots, and `N` a matrix of size `(nLots x sizeLot)` 
of the number of bacteria per units. Each unit is the amount of a future bag of frozen
vegetables of size `unitSize` grams.


```{r}
# Production level
set.seed(12345)
nLots <- 5000
sizeLot <- 1000 # Units: bag of frozen V
servingUnit <- 5
unitSize <- 500
# Initial Prevalence
# P0 <- 0.054
# Initial contamination
betaAlpha <- 0.5112
betaBeta <- 9.959 / 5
C0MeanLog <- 1.023
C0SdLog <- 0.3267
propVarInter <- 0.7

dat <- Lot2LotGen(
  nLots = nLots,
  sizeLot = sizeLot,
  unitSize = unitSize,
  betaAlpha = betaAlpha,
  betaBeta = betaBeta,
  C0MeanLog = C0MeanLog,
  C0SdLog = C0SdLog,
  propVarInter = 0.7
)
```

### Summary statistics: between lots LM counts

```{r}
summaryLot.qraLm(dat)
```

### Summary statistics: within lots (between units) mean counts

```{r}
summaryUnits.qraLm(dat)
```

```{r}
# plotLotsECDF.qraLm(dat)
```

## Blanching {data-icon="fa-free-code-camp"}

Blanching step is an inactivation step. Unit definition is unchanged.

```{r}
logDrefMean <- -1.78
logDrefSd <- 0.251
zT <- 6.06
tempBlanch <- 83 # 85
timeBlanch <- 0.75 # 1

# Blanching level
datBlanch <- fvBlanching(dat,
  tempBlanch = tempBlanch,
  timeBlanch = timeBlanch,
  logDrefMean = logDrefMean,
  logDrefSd = logDrefSd,
  zT = zT
)
```

### Summary statistics: between lots LM counts

```{r}
summaryLot.qraLm(datBlanch)
```

### Summary statistics: within lots (between units) mean counts

```{r}
summaryUnits.qraLm(datBlanch)
```


## Partitioning and cross-contamination

This step mimics the actual partitioning of frozen vegetables in bags. It is a step 
of potential cross-contaminations. The unit is unchanged (because the amount of 
vegetables in bags are what was considered before).

```{r}
# Partitioning level
probCC <- 0.25
trMean <- -0.44
trSd <- 0.40
nEquip <- 9 * 5000 # not running with 9 or 25
bCCFV <- 1

datPart <- fvPartitioningCC(datBlanch,
  probCC = probCC,
  trMean = trMean,
  trSd   = trSd,
  nEquip = nEquip,
  bCCFV  = bCCFV
)
```

### Summary statistics: between lots LM counts

```{r}
summaryLot.qraLm(datPart)
```

### Summary statistics: within lots (between units) mean counts

```{r}
summaryUnits.qraLm(datPart)
```
  

## Testing (optional)

This is an optional step of testing (mitigation) using . Here, the testing is off because `pLotTested == 0`. 

```{r}
# Testing level
nTested <- 5
gTested <- 25
MTested <- 0
cTested <- 0
pLotTested <- 0
Se <- 1
gTestedEnum <- 10
iterSub <- NULL

datTest <- fvTesting(datPart,
  nTested = nTested,
  gTested = gTested,
  MTested = MTested,
  cTested = cTested,
  pLotTested = pLotTested,
  unitSize = unitSize,
  Se = Se
)
```

### Summary statistics: between lots LM counts

```{r}
summaryLot.qraLm(datTest)
```

### Summary statistics: within lots (between units) mean counts

```{r}
summaryUnits.qraLm(datTest)
```


### Proportion of discarded lots

```{r}
# MC stats
cat(paste0("Proportion of discarded lots: ", datTest$D * 100, "%\n"))
```

### prevalence of contaminated units at the end of processing

```{r}
### prevalence of contaminated units at the end of processing
prevEndProcessing <- weighted.mean(datTest$ProbUnitPos * (datTest$N != 0),
  w = rep(1, length(datTest$N))
)
prevEndProcessing
```


### Assessment in CFU per lot

```{r}
# assessment in CFU per lot
cat("overall P:", mean(datTest$ProbUnitPos * rowMeans(datTest$N != 0)), "\n")
# cat("overall N:", mean(res8$ProbUnitPos * rowSums(res8$N)),"\n")

cat("overall P>10:", weighted.mean(rowMeans(datTest$N / unitSize >= 10), w = datTest$ProbUnitPos), "\n")
cat("overall P>100:", weighted.mean(rowMeans(datTest$N / unitSize >= 100), w = datTest$ProbUnitPos), "\n")
```


## Portioning

This function represents the portioning of a pack of frozen vegetables into a smaller unit (serving size, in g).
The lot structure is not used anymore following this step.

```{r}
# Portioniong level
servingSize <- 50
unitSize <- 500
bPort <- 1
datPortio <- fvPortioning(datTest,
  servingSize = servingSize,
  unitSize = unitSize,
  bPort = bPort
)
```

### Summary statistics: between lots LM counts

```{r}
summaryLot.qraLm(datPortio)
```

### Summary statistics: within lots (between units) mean counts

```{r}
summaryUnits.qraLm(datPortio)
```


## Defrosting

This function simulates the possibility that consumers thaw frozen vegetables prior to cooking or consumption.
This is a potential growth step. Here, the function is off.

```{r}
# Defrost level
Temp <- 8
time <- 2
MPD <- 8
Tmin <- -1.18
meanEGR5 <- 0.0117
sdEGR5 <- 0.00816
servingSize <- 50
pDefrost <- 0
datDefrost <- fvDefrost(datPortio,
  Temp = Temp,
  time = time,
  MPD = MPD,
  Tmin = Tmin,
  meanEGR5 = meanEGR5,
  sdEGR5 = sdEGR5,
  servingSize = servingSize,
  pDefrost = pDefrost
)
```

### Summary statistics: between lots LM counts

```{r}
summaryLot.qraLm(datDefrost)
```

### Summary statistics: within lots (between units) mean counts

```{r}
summaryUnits.qraLm(datDefrost)
```


## Cooking    

This is an inactivation step at the consumer home. 

```{r}
# Cooking level
pCooked <- 1.0
minCook <- 1.0
modeCook <- 5.0
maxCook <- 9.0

datCook <- fvCooking(datPortio,
  pCooked = pCooked,
  minCook = minCook,
  modeCook = modeCook,
  maxCook = maxCook
)
```


### Summary statistics: between lots LM counts

```{r}
summaryLot.qraLm(datCook)
```

### Summary statistics: within lots (between units) mean counts

```{r}
summaryUnits.qraLm(datCook)
```


## Risk

We integrate the dose-response model

```{r}
# Dose response
DRmodel <- "JEMRA"
population <- 2
risk <- DRForModel(datCook,
                   model = DRmodel,
                   population = population
)
str(risk)
```

### Risk statistics between lots

```{r}
summaryLot.qraLm(risk)
```

### Risk statistics within lots

```{r}
summaryUnits.qraLm(risk)
```

### Risk distribution (contaminated servings)

```{r}
plotRisk.qraLm(risk)
```

